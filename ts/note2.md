#模块化

      配置名称                    含义

      module            设置编译结果中使用的模块化标准
  modeleResolution          设置解析模块的模式
noImplicitUseStrict     编译结果中不包含"use strict"
  removeComments             编译结果移除注释
  noEmitOnError           错误时不生成编译结果
  esModuleInterop       启用es模块化交互非es模块导出

> 前端领域中的模块化标准： es6、commonjs、amd、und、system

#TS中如何书写模块化语句
导入和导出模块，统一使用es6的模块化标准

#编译结果中的模块化
可配置

TS中的模块化在编译结果中

- 如果编译结果的模块化标准是es6：没有区别
- 如果是commonjs： 导出的声明会变成export的属性，默认导出会变成export的default属性
import * as xx from 'xx'  或者 import {xx} from 'xx'

#如何在TS中书写commonjs模块化代码
一般不建议

#模块解析

模块解析： 应该从什么位置寻找模块

TS中，有两种模块解析策略

- classic ： 经典
- node： node解析策略

"build": "rd /s dist & tsc" //每次build都重新删除dist文件夹再build

# 接口和类型兼容性

#扩展类型 - 接口
> 扩展类型： 类型别名、枚举、接口、类

ts的接口： 用于约束类、对象、函数的契约（标准）
不出现在编译结果中

1. 接口约束对象
2. 接口约束函数

#接口可以继承
可以继承多个  interface b extends A,C {t3:string}

使用类型别名可以实现类似组合效果，需要用&，type C = {t1:number} & b & a

区别： 
- 交叉类型会把相同成员的类型进行交叉
- 子接口不能覆盖父接口的成员

**readonly**

只读修饰符，修饰的目标是只读。不在编译结果中。readonly id:string  
对象的属性不能更改。

#类型兼容性

鸭子辩型法（子结构辩型法）： 目标类型需要某一些特征，赋值的类型只要能满足该特征即可

- 基本类型：完全匹配
- 对象类型：鸭子辩型法

可选参数，可有可无。对象的属性也可以设置  interface User { name?: string}

类型断言    {} as card | <Card>{}  react中不推荐第二种
当直接使用对象字面量直接赋值的时候，会使用更严格的判断。

- 函数类型  通常出现在回调

**参数**
传递给目标函数的参数可以少但不可以多

**返回值**
要求返回必须返回;不要求返回的时候，你随意

#TS的类 
> 面向对象思想

**属性**
使用属性列表来描述类中的属性

**属性的初始化检查**

设置"strictPropertyInitialization": true 

1.构造函数中
2.属性默认值

初始化可以在构造参数传入的参数中或者在属性列表中完成。前提是知道默认值。
gerder: "男" | "女" = "男"   |  constructor(name: string, gender: "男" | "女" = "男")

**属性可以修饰成可读的**  readonly id: number   
属性可有可无  pid? : string

**使用访问修饰符**  可以控制类中的某个成员的访问权限
- public: 默认的访问修饰符，公开的，所有的代码均可访问

- private：私有的，只有在类中可以访问(属性、方法都可以)   private publishNumber: number = 3   用函数自己改变。
尽量少暴露成员，不需要外面知道的，私有化。
- protected

**属性简写**
如果某个属性，通过构造函数的参数传递，并且不做任何处理的赋值。可以进行简写。
public name:string ->不需要this.name = name 和在属性列表中声明

Symble  //js中  外面的人不可以访问到的属性

**访问器** 控制属性的读取和赋值
set  get 注意：大部分是设置私有属性

#泛型：是指附属于函数、类、接口、类型别名之上的类型
有时候，书写某个函数时，会丢失一些类型信息（多个位置的类型应该保持一致或者有关联信息）

- 在函数中使用： 在函数名之后写上<泛型名称>  
在书写的时候不确定function take<T>(){},在调用的时候传一个类型 take<number> {}





## 泛型相当于是一个类型变量，在定义时，无法预先知道具体的类型，可以用该变量代替，
只有到调用时```take<number>()```，才可以确定其类型

很多时候，ts会智能的根据传递的参数，推导出泛型的具体类型

如果无法完成推导，并且又没有传递具体的类型，默认为空对象

泛型还可以设置默认值

# 如何在类型别名、接口、类中使用泛型

直接在名称后写上 <泛型名称>  

#泛型约束







